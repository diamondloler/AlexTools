{"version":3,"sources":["mm-tools.js"],"names":["root","factory","define","amd","exports","module","MMTools","global","window","this","merge","target","i","arguments","length","source","key","hasOwnProperty","undefined","cloneDeep","obj","JSON","parse","stringify","matchTerminal","matchArray","checkString","isEnd","flag","regExpStart","regExpEnd","forEach","val","RegExp","test","tagFliter","replace","copyWithin","arr","start","end","target_","start_","end_","nagative_flag","target_reactive","rangeError","j","keyTransverter","targetKeys","originKeys","origin","len"],"mappings":"CAAA,SAAAA,EAAAC,GACA,mBAAAC,QAAAA,OAAAC,IACAD,UAAA,WACA,OAAAD,EAAAD,KAEA,iBAAAI,SAAA,oBAAAC,OACAA,OAAAD,QAAAH,EAAAD,GAEAA,EAAAM,QAAAL,EAAAD,GARA,CAUA,oBAAAO,OAAAA,OAAA,oBAAAC,OAAAA,OAAAC,KAAA,SAAAD,GAiJA,OA3HAE,MAAA,SAAAC,GACA,IAAA,IAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAA,CACA,IAAAG,EAAAF,UAAAD,OACA,IAAA,IAAAI,KAAAD,EACAA,EAAAE,eAAAD,SAAAE,IAAAH,EAAAC,KACAL,EAAAK,GAAAD,EAAAC,IAIA,OAAAL,GAUAQ,UAAA,SAAAC,GACA,OAAAC,KAAAC,MAAAD,KAAAE,UAAAH,KAaAI,cAAA,SAAAC,EAAAC,EAAAC,GACA,IAAAC,GAAA,EACAC,EAAA,IACAC,EAAA,IAWA,OATAH,EAAAA,IAAA,GACAG,EAAA,KAAAD,EAAA,KAEAJ,EAAAM,QAAA,SAAAC,GACA,IAAAC,OAAAJ,EAAAG,EAAAF,GAAAI,KAAAR,KACAE,GAAA,KAIAA,GAWAO,UAAA,SAAAH,GACA,OAAAA,EAAAI,QAAA,gBAAA,KAeAC,WAAA,SAAAC,EAAA3B,EAAA4B,EAAAC,GACA,IAAAC,GAAA9B,EAAA,EAAA2B,EAAAxB,OAAAH,EAAAA,IAAA,EACA+B,GAAAH,EAAA,EAAAD,EAAAxB,OAAAyB,EAAAA,IAAA,EACAI,GAAAH,EAAA,EAAAF,EAAAxB,OAAA0B,EAAAA,IAAAF,EAAAxB,OAEA8B,EAAAL,EAAA,GAAAC,EAAA,EACAK,EAAAlC,EAAA,EAAA,GAAA,EAEA,GAAA8B,EAAAH,EAAAxB,OACA,MAAA,IAAAgC,WAAA,gEAKA,GAFAR,EAAAG,GAAAH,EAAAI,GAEAE,EAKA,IAAAhC,EAAA8B,EAAAK,EAAAF,EAAAF,EAAA/B,EAAAA,IAAAmC,GAAAF,EACAP,EAAAG,EAAAM,GAAAT,EAAA1B,EAAA,QALA,IAAA,IAAAA,EAAA8B,EAAAK,EAAA,EAAAnC,EAAA+B,EAAA/B,IAAAmC,IACAT,EAAAG,EAAAM,GAAAT,EAAA1B,EAAA,GAQA,OAAA0B,GAYAU,eAAA,SAAAC,EAAAC,EAAAC,GAEA,IADA,IAAAxC,KACAC,EAAA,EAAAwC,EAAAH,EAAAnC,OAAAF,EAAAwC,EAAAxC,IACAD,EAAAsC,EAAArC,IAAAuC,EAAAD,EAAAtC,IAEA,OAAAD","file":"mm-tools.min.js","sourcesContent":[" (function (root, factory) {\r\n     if (typeof define === 'function' && define.amd) {\r\n         define([], function () {\r\n             return factory(root);\r\n         });\r\n     } else if (typeof exports === \"object\" && typeof module !== \"undefined\") {\r\n         module.exports = factory(root);\r\n     } else {\r\n         root.MMTools = factory(root);\r\n     }\r\n })(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this, function (window) {\r\n     var mixmediaToolsFactory = function () {\r\n\r\n\r\n\r\n\r\n         /**\r\n          * 这个是mixmedia的前端工具库，写入常用的method，或把兼容性不好的es5 api 补丁到这里，日后方便大家开发，\r\n          * 欢迎各位同事来添加api\r\n          */\r\n         var publicApis = {};\r\n\r\n\r\n\r\n\r\n         /**\r\n          * 合并对象\r\n          * 替换es2015api - Object.assign(target,scource[,,,,])(IE不支持)\r\n          * @param {Object} target 合并的目标\r\n          * @param {Object} arguments index begin with 1, 2, 3... (要合并到目标的对象资源)\r\n          * @return {Object} 已合并的对象\r\n          */\r\n         publicApis.merge = function (target) {\r\n             for (var i = 1; i < arguments.length; i++) {\r\n                 var source = arguments[i] || {};\r\n                 for (var key in source) {\r\n                     if (source.hasOwnProperty(key) && source[key] !== undefined) {\r\n                         target[key] = source[key]\r\n                     }\r\n                 }\r\n             }\r\n             return target;\r\n         }\r\n\r\n\r\n\r\n         /**\r\n          * 深度克隆对象\r\n          * @param {Object} obj \r\n          * @return {Object}\r\n          */\r\n         publicApis.cloneDeep = function (obj) {\r\n             return JSON.parse(JSON.stringify(obj));\r\n         }\r\n\r\n\r\n\r\n\r\n         /**\r\n          * 匹配字符串数组每个元素的起始部分或终点部分，假如数组中某一个字符串与验证字符串匹配成功 则返回true\r\n          * @param {Array} matchArray 匹配的字符串数组\r\n          * @param {String} checkString 需要验证的字符串\r\n          * @param {String} isEnd 是否匹配末尾部分 默认 否\r\n          * @return {Boolean}\r\n          */\r\n         publicApis.matchTerminal = function (matchArray, checkString, isEnd) {\r\n             var flag = false;\r\n             var regExpStart = '(';\r\n             var regExpEnd = ')';\r\n\r\n             isEnd = isEnd || false;\r\n             !isEnd ? regExpStart = '^(' : regExpEnd = ')$';\r\n\r\n             matchArray.forEach(function (val) {\r\n                 if (new RegExp(regExpStart + val + regExpEnd).test(checkString)) {\r\n                     flag = true;\r\n                 }\r\n             })\r\n\r\n             return flag;\r\n         }\r\n\r\n\r\n\r\n\r\n         /**\r\n          * html标签过滤器\r\n          * @param {String} val 将要过滤的字符串\r\n          * @return {String}\r\n          */\r\n         publicApis.tagFliter = function (val) {\r\n             return val.replace(/(\\<\\/?\\w+\\>)/g, '');\r\n         }\r\n\r\n\r\n\r\n         /**\r\n          * 浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。\r\n          * 替换es2015的Array.copyWithin(target, start, end)---不支持IE\r\n          * @param {Array} arr 将要被浅复制的数组\r\n          * @param {Number} target 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算\r\n          * @param {Number} start 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。\r\n          * @param {Number} end  0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，\r\n          * 但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。\r\n          * @return {Array} \r\n          */\r\n         publicApis.copyWithin = function (arr, target, start, end) {\r\n             var target_ = (target < 0 ? arr.length + target : target) || 0,\r\n                 start_ = (start < 0 ? arr.length + start : start) || 0,\r\n                 end_ = (end < 0 ? arr.length + end : end) || arr.length;\r\n\r\n             var nagative_flag = start < 0 && end < 0 ? true : false;\r\n             var target_reactive = target < 0 ? 1 : -1;\r\n\r\n             if (target_ > arr.length) {\r\n                 throw new rangeError('The 1st parameter must less than length of the 2nd parameter');\r\n             }\r\n\r\n             arr[target_] = arr[start_];\r\n\r\n             if (!nagative_flag) {\r\n                 for (var i = start_, j = 1; i < end_; i++, j++) {\r\n                     arr[target_ + j] = arr[i + 1]\r\n                 }\r\n             } else {\r\n                 for (var i = start_, j = target_reactive; i > end_; i--, j += target_reactive) {\r\n                     arr[target_ - j] = arr[i - 1]\r\n                 }\r\n             }\r\n\r\n             return arr;\r\n         }\r\n\r\n\r\n\r\n         /** \r\n          * 对象key转换器\r\n          * @param {Array} targetKeys 你想转换成的key集合\r\n          * @param {Array} originKeys 源key集合\r\n          * @param {Object} origin 源对象\r\n          * @return {Object}  返回一个含有 targetKeys 的对象\r\n          */\r\n         publicApis.keyTransverter = function (targetKeys, originKeys, origin) {\r\n             var target = {}\r\n             for (var i = 0, len = targetKeys.length; i < len; i++) {\r\n                 target[targetKeys[i]] = origin[originKeys[i]]\r\n             }\r\n             return target\r\n         }\r\n\r\n         //return apis\r\n         return publicApis;\r\n\r\n     }\r\n\r\n     return mixmediaToolsFactory();\r\n })"]}